#!/usr/bin/env python3
"""
ü§ñ Grace Bot com MayAPI - Sistema Completo Anti-Fraude
Integra√ß√£o WhatsApp + IA + Agentes Anti-Fraude
"""

import os
import requests
import json
import uuid
import re
from groq import Groq
from flask import Flask, request, jsonify
from dotenv import load_dotenv

# Importar agentes
from agente_leitor import AgenteLeitorOCR
from agente_consultor import AgenteConsultor
from agente_detetive import AgenteDetetive
from mayapi_client import MayAPIClient

# Carregar vari√°veis de ambiente
load_dotenv()

# ==================== CONFIGURA√á√ÉO ====================

MAYAPI_PRODUCT_ID = os.getenv('MAYAPI_PRODUCT_ID')
MAYAPI_TOKEN = os.getenv('MAYAPI_TOKEN')
GROQ_API_KEY = os.getenv('GROQ_API_KEY')

# ==================== FUN√á√ÉO OCR ====================

def extrair_dados_boleto_ocr(texto):
    """Extrai dados espec√≠ficos de boleto usando regex"""
    dados = {}
    
    # Padr√µes para extrair dados
    padroes = {
        'valor': [
            r'R\$\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)',
            r'(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)\s*reais',
            r'valor[:\s]*R?\$?\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)'
        ],
        'vencimento': [
            r'(\d{1,2}/\d{1,2}/\d{2,4})',
            r'vencimento[:\s]*(\d{1,2}/\d{1,2}/\d{2,4})',
            r'data[:\s]*(\d{1,2}/\d{1,2}/\d{2,4})'
        ],
        'banco': [
            r'(banco\s+do\s+brasil|bb)',
            r'(bradesco)',
            r'(itau|ita√∫)',
            r'(santander)',
            r'(caixa\s+econ√¥mica\s+federal|cef)',
            r'(nubank)',
            r'(inter)'
        ],
        'codigo_barras': [
            r'(\d{47})',  # C√≥digo de barras padr√£o
            r'(\d{44})',  # C√≥digo de barras alternativo
        ],
        'beneficiario': [
            r'benefici√°rio[:\s]*([A-Za-z\s]+)',
            r'favorecido[:\s]*([A-Za-z\s]+)',
            r'pagador[:\s]*([A-Za-z\s]+)'
        ],
        'cpf_cnpj': [
            r'(\d{3}\.?\d{3}\.?\d{3}-?\d{2})',  # CPF
            r'(\d{2}\.?\d{3}\.?\d{3}/?\d{4}-?\d{2})',  # CNPJ
        ],
        'numero_documento': [
            r'nosso\s+n√∫mero[:\s]*(\d+)',
            r'seu\s+n√∫mero[:\s]*(\d+)',
            r'documento[:\s]*(\d+)',
            r'n√∫mero[:\s]*(\d+)'
        ]
    }
    
    # Extrair dados usando regex
    for campo, lista_padroes in padroes.items():
        for padrao in lista_padroes:
            match = re.search(padrao, texto, re.IGNORECASE)
            if match:
                dados[campo] = match.group(1) if match.groups() else match.group(0)
                break
    
    return dados

# ==================== CLASSE MAYAPI ====================

class MayAPIWhatsApp:
    def __init__(self):
        """Inicializa cliente MayAPI"""
        self.product_id = MAYAPI_PRODUCT_ID
        self.token = MAYAPI_TOKEN
        self.base_url = f"https://api.maytapi.com/api/{self.product_id}"
        self.headers = {
            "x-maytapi-key": self.token,
            "accept": "application/json",
            "Content-Type": "application/json"
        }
    
    def enviar_mensagem(self, numero, texto):
        """Envia mensagem de texto via MayAPI"""
        try:
            payload = {
                "to_number": numero,
                "type": "text",
                "message": texto
            }
            
            # Phone ID vai na URL, n√£o no payload
            response = requests.post(
                f"{self.base_url}/113863/sendMessage",
                headers=self.headers,
                json=payload,
                timeout=10
            )
            
            print(f"üì§ Enviando para {numero}: {texto}")
            print(f"üì§ Resposta MayAPI: {response.status_code} - {response.text}")
            
            return response.json()
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar mensagem: {e}")
            return {'erro': str(e)}
    
    def enviar_com_botoes(self, numero, texto, botoes):
        """Envia mensagem com op√ß√µes numeradas (MayAPI n√£o suporta bot√µes interativos)"""
        try:
            # MayAPI n√£o suporta bot√µes interativos, usar op√ß√µes numeradas
            texto_com_opcoes = f"{texto}\n\n"
            for i, botao in enumerate(botoes[:3], 1):
                emoji = ["1Ô∏è‚É£", "2Ô∏è‚É£", "3Ô∏è‚É£"][i-1]
                texto_com_opcoes += f"{emoji} {botao}\n"
            
            texto_com_opcoes += "\nDigite o n√∫mero da op√ß√£o desejada."
            
            payload = {
                "to_number": numero,
                "type": "text",
                "message": texto_com_opcoes
            }
            
            # Phone ID vai na URL, n√£o no payload
            response = requests.post(
                f"{self.base_url}/113863/sendMessage",
                headers=self.headers,
                json=payload,
                timeout=10
            )
            
            print(f"üì§ Enviando op√ß√µes numeradas para {numero}: {botoes}")
            print(f"üì§ Resposta MayAPI: {response.status_code} - {response.text}")
            
            return response.json()
            
        except Exception as e:
            print(f"‚ùå Erro ao enviar op√ß√µes: {e}")
            return {'erro': str(e)}
    
    def baixar_imagem(self, media_id):
        """Baixa imagem via MayAPI"""
        try:
            response = requests.get(
                f"{self.base_url}/getMedia/{media_id}",
                headers=self.headers,
                timeout=10
            )
            
            if response.status_code == 200:
                # Salvar imagem temporariamente
                import tempfile
                temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')
                temp_file.write(response.content)
                temp_file.close()
                return temp_file.name
            else:
                return None
                
        except Exception as e:
            print(f"‚ùå Erro ao baixar imagem: {e}")
            return None

# ==================== AGENTE ORQUESTRADOR ====================

class AgenteOrquestrador:
    def __init__(self):
        """Inicializa o Agente Orquestrador com todos os agentes"""
        self.leitor = AgenteLeitorOCR()
        self.consultor = AgenteConsultor()
        self.detetive = AgenteDetetive()
        self.mayapi = MayAPIClient(MAYAPI_PRODUCT_ID, MAYAPI_TOKEN)
    
    def analisar_pagamento_completo(self, cliente_id, dados_pagamento):
        """An√°lise completa multi-agente"""
        try:
            print("üîç Agente Leitor: Extraindo dados...")
            # 1. EXTRA√á√ÉO (Agente Leitor)
            if dados_pagamento.get('tipo') == 'imagem_boleto':
                dados_extraidos = self.leitor.extrair_dados_boleto(dados_pagamento.get('path', ''))
            elif dados_pagamento.get('tipo') == 'pix':
                dados_extraidos = self.leitor.extrair_dados_pix(dados_pagamento.get('codigo', ''))
            else:
                dados_extraidos = dados_pagamento
            
            print("‚úÖ Agente Consultor: Validando internamente...")
            # 2. VALIDA√á√ÉO (Agente Consultor)
            validacao = self.consultor.validar_cobranca(cliente_id, dados_extraidos)
            
            print("üïµÔ∏è Agente Detetive: Analisando fraudes...")
            # 3. DETEC√á√ÉO (Agente Detetive)
            analise_fraude = self.detetive.analisar_fraude_completa(dados_extraidos, cliente_id)
            
            # 4. CONSOLIDA√á√ÉO
            score_final = self._calcular_score_final(validacao, analise_fraude)
            
            resultado = {
                'dados_extraidos': dados_extraidos,
                'validacao_interna': validacao,
                'analise_fraude': analise_fraude,
                'score_confianca': score_final,
                'classificacao': self._classificar_final(score_final),
                'mensagem_usuario': self._gerar_mensagem(score_final, analise_fraude),
                'timestamp': dados_pagamento.get('timestamp', '')
            }
            
            return resultado
            
        except Exception as e:
            return {
                'erro': f'Erro na an√°lise completa: {str(e)}',
                'score_confianca': 0,
                'classificacao': 'ERRO'
            }
    
    def _calcular_score_final(self, validacao, fraude):
        """Combina scores de valida√ß√£o e fraude"""
        score_validacao = validacao.get('score_confianca', 0)
        score_fraude_invertido = 100 - fraude.get('score_fraude', 0)
        
        # Peso maior para detec√ß√£o de fraude (seguran√ßa first)
        score_final = (score_validacao * 0.4) + (score_fraude_invertido * 0.6)
        return round(score_final)
    
    def _classificar_final(self, score):
        """Classifica√ß√£o final visual"""
        if score >= 90:
            return "üü¢ SEGURO"
        elif score >= 60:
            return "üü° SUSPEITO"
        else:
            return "üî¥ FRAUDE"
    
    def _gerar_mensagem(self, score, analise_fraude):
        """Mensagem amig√°vel pro usu√°rio"""
        if score >= 90:
            return "‚úÖ Pode pagar com tranquilidade! Tudo verificado."
        elif score >= 60:
            sinais = analise_fraude.get('sinais_suspeitos', [])
            return f"‚ö†Ô∏è Aten√ß√£o! Encontramos: {', '.join(sinais[:2])}. Confirme antes de pagar."
        else:
            sinais = analise_fraude.get('sinais_suspeitos', [])
            return f"üö® N√ÉO PAGUE! Detectamos fraude: {', '.join(sinais[:3])}"

# ==================== CLASSE IA ====================

class GraceIA:
    def __init__(self):
        self.client = Groq(api_key=GROQ_API_KEY)
        self.historico = {}
        self.contexto_conversa = {}  # Novo: contexto de conversa por usu√°rio
    
    def processar_mensagem(self, usuario_id, mensagem):
        """Processa mensagem com IA mantendo contexto"""
        try:
            # Inicializar hist√≥rico do usu√°rio se n√£o existir
            if usuario_id not in self.historico:
                self.historico[usuario_id] = []
            if usuario_id not in self.contexto_conversa:
                self.contexto_conversa[usuario_id] = {
                    'ultima_acao': None,
                    'dados_pagamento': {},
                    'fluxo_atual': None
                }
            
            # System prompt
            system_prompt = """
            Voc√™ √© a Grace, assistente inteligente de pagamentos da Bemobi.
            
            PERSONALIDADE:
            - Amig√°vel, emp√°tica e prestativa
            - Explica coisas complexas de forma simples
            - Proativa em oferecer solu√ß√µes
            - Usa emojis com modera√ß√£o
            
            CAPACIDADES:
            - Ajudar com pagamentos (Pix, Boleto, Cart√£o)
            - Verificar faturas e cobran√ßas
            - Detectar fraudes
            - Tirar d√∫vidas sobre servi√ßos
            - Negociar d√≠vidas
            
            REGRAS:
            - Respostas curtas (m√°x 3 linhas no WhatsApp)
            - Use emojis com modera√ß√£o
            - Sempre confirme dados sens√≠veis
            - Em caso de suspeita de fraude, alerte IMEDIATAMENTE
            - Mantenha contexto da conversa anterior
            """
            
            # Adicionar contexto do hist√≥rico e fluxo atual
            contexto = ""
            if self.historico[usuario_id]:
                contexto += f"\nHist√≥rico recente: {', '.join(self.historico[usuario_id][-3:])}"
            
            # Adicionar contexto da conversa atual
            ctx = self.contexto_conversa[usuario_id]
            if ctx['ultima_acao']:
                contexto += f"\n√öltima a√ß√£o: {ctx['ultima_acao']}"
            if ctx['fluxo_atual']:
                contexto += f"\nFluxo atual: {ctx['fluxo_atual']}"
            if ctx['dados_pagamento']:
                contexto += f"\nDados coletados: {ctx['dados_pagamento']}"
            
            # Chamada para Groq
            chat_completion = self.client.chat.completions.create(
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"{mensagem}{contexto}"}
                ],
                model="llama-3.1-8b-instant",
                temperature=0.7,
                max_tokens=200
            )
            
            resposta = chat_completion.choices[0].message.content
            
            # Atualizar hist√≥rico
            self.historico[usuario_id].append(mensagem)
            if len(self.historico[usuario_id]) > 10:
                self.historico[usuario_id] = self.historico[usuario_id][-10:]
            
            return resposta
            
        except Exception as e:
            return f"Desculpe, ocorreu um erro: {str(e)}"
    
    def detectar_intencao(self, mensagem, usuario_id=None):
        """Detecta inten√ß√£o do usu√°rio com contexto"""
        try:
            mensagem_lower = mensagem.lower().strip()
            
            # Verificar contexto primeiro
            if usuario_id and usuario_id in self.contexto_conversa:
                ctx = self.contexto_conversa[usuario_id]
                
                # Se est√° no fluxo de pagamento e usu√°rio responde com n√∫meros
                if mensagem_lower in ['1', '2', '3'] and ctx['fluxo_atual'] == 'escolher_pagamento':
                    return f"escolher_pagamento_{mensagem_lower}"
                
                # Se est√° no fluxo de verifica√ß√£o e usu√°rio responde com n√∫meros
                elif mensagem_lower in ['1', '2', '3'] and ctx['fluxo_atual'] == 'escolher_verificacao':
                    return f"escolher_verificacao_{mensagem_lower}"
                
                # Se est√° coletando dados e usu√°rio informa valor
                elif ctx['fluxo_atual'] == 'dados_boleto' and any(palavra in mensagem_lower for palavra in ['valor', 'reais', 'r$', 'dinheiro', '500', '506']):
                    return "informar_valor"
                
                # Se est√° no fluxo e usu√°rio quer continuar
                elif any(palavra in mensagem_lower for palavra in ['continuar', 'confirmar', 'sim', 'ok', 'prosseguir']):
                    if ctx['fluxo_atual'] == 'dados_boleto':
                        return "continuar_pagamento"
                    elif ctx['fluxo_atual'] == 'escolher_pagamento':
                        return "continuar_pagamento"
                
                # Se est√° no fluxo e usu√°rio quer cancelar
                elif any(palavra in mensagem_lower for palavra in ['cancelar', 'parar', 'n√£o', 'sair']):
                    return "cancelar"
            
            # Detec√ß√£o por palavras-chave (apenas se n√£o estiver em fluxo)
            if any(palavra in mensagem_lower for palavra in ['pagar', 'pagamento', 'pix', 'boleto', 'cart√£o', 'dinheiro', 'valor', 'quero pagar']):
                return "pagar"
            elif any(palavra in mensagem_lower for palavra in ['verificar', 'consultar', 'status', 'fatura', 'cobran√ßa', 'ver']):
                return "verificar"
            elif any(palavra in mensagem_lower for palavra in ['cancelar', 'parar', 'n√£o quero']):
                return "cancelar"
            elif any(palavra in mensagem_lower for palavra in ['valor', 'reais', 'r$', 'dinheiro']):
                return "informar_valor"
            else:
                # Se n√£o encontrou palavra-chave, usa IA
                prompt = f"""
                Analise a mensagem e retorne APENAS uma palavra:
                Mensagem: "{mensagem}"
                
                Op√ß√µes: pagar, verificar, duvida, consultar, cancelar, informar_valor, continuar_pagamento
                
                Se a mensagem menciona pagamento, dinheiro, pix, boleto, cart√£o, retorne "pagar"
                Se a mensagem menciona verificar, consultar, status, retorne "verificar"
                Se a mensagem menciona valor, reais, R$, retorne "informar_valor"
                Se a mensagem menciona continuar, confirmar, prosseguir, retorne "continuar_pagamento"
                """
                
                response = self.client.chat.completions.create(
                    messages=[{"role": "user", "content": prompt}],
                    model="llama-3.1-8b-instant",
                    temperature=0.1,
                    max_tokens=10
                )
                
                return response.choices[0].message.content.strip().lower()
            
        except Exception as e:
            return "duvida"

# ==================== FUN√á√ÉO AUXILIAR ====================

def processar_mensagem_com_contexto(numero_usuario, texto):
    """Processa mensagem mantendo contexto da conversa"""
    # Detectar inten√ß√£o com contexto
    intencao = ia.detectar_intencao(texto, numero_usuario)
    print(f"üéØ Inten√ß√£o detectada: {intencao}")
    
    # Atualizar contexto da conversa
    if numero_usuario not in ia.contexto_conversa:
        ia.contexto_conversa[numero_usuario] = {
            'ultima_acao': None,
            'dados_pagamento': {},
            'fluxo_atual': None
        }
    
    # Debug do contexto
    ctx = ia.contexto_conversa[numero_usuario]
    print(f"üß† Contexto atual: {ctx}")
    
    # Processar com base na inten√ß√£o e contexto
    if intencao == 'pagar':
        # Iniciar fluxo de pagamento
        ia.contexto_conversa[numero_usuario]['fluxo_atual'] = 'escolher_pagamento'
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = 'solicitou_pagamento'
        texto_botoes = "Escolha como deseja pagar:"
        botoes = ["Pix", "Cartao", "Boleto"]
        whatsapp.enviar_com_botoes(numero_usuario, texto_botoes, botoes)
        
    elif intencao.startswith('escolher_pagamento_'):
        # Usu√°rio escolheu m√©todo de pagamento
        opcao = intencao.split('_')[-1]
        metodos = {1: 'Pix', 2: 'Cart√£o', 3: 'Boleto'}
        metodo_escolhido = metodos.get(int(opcao), 'Pix')
        
        ia.contexto_conversa[numero_usuario]['dados_pagamento']['metodo'] = metodo_escolhido
        ia.contexto_conversa[numero_usuario]['fluxo_atual'] = 'dados_boleto'
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = f'escolheu_{metodo_escolhido.lower()}'
        
        if metodo_escolhido == 'Boleto':
            resposta = f"Perfeito! Voc√™ escolheu {metodo_escolhido}. Qual √© o valor do boleto que voc√™ quer pagar?"
        else:
            resposta = f"√ìtima escolha! {metodo_escolhido} √© r√°pido e seguro. Qual √© o valor que voc√™ quer pagar?"
        
        whatsapp.enviar_mensagem(numero_usuario, resposta)
        
    elif intencao == 'informar_valor':
        # Usu√°rio informou valor
        ia.contexto_conversa[numero_usuario]['dados_pagamento']['valor'] = texto
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = 'informou_valor'
        ia.contexto_conversa[numero_usuario]['fluxo_atual'] = 'confirmar_pagamento'
        
        metodo = ia.contexto_conversa[numero_usuario]['dados_pagamento'].get('metodo', 'pagamento')
        resposta = f"‚úÖ Perfeito! Valor de {texto} via {metodo}.\n\nPara finalizar o pagamento, preciso confirmar alguns dados:\n\n1Ô∏è‚É£ N√∫mero da conta\n2Ô∏è‚É£ CPF\n3Ô∏è‚É£ Confirma√ß√£o\n\nDigite 'continuar' para prosseguir ou 'cancelar' para sair."
        whatsapp.enviar_mensagem(numero_usuario, resposta)
        
    elif intencao == 'continuar_pagamento':
        # Usu√°rio quer continuar com o pagamento
        ctx = ia.contexto_conversa[numero_usuario]
        metodo = ctx['dados_pagamento'].get('metodo', 'pagamento')
        valor = ctx['dados_pagamento'].get('valor', 'n√£o informado')
        
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = 'confirmou_pagamento'
        ia.contexto_conversa[numero_usuario]['fluxo_atual'] = 'finalizando'
        
        resposta = f"üéâ √ìtimo! Vamos finalizar seu pagamento:\n\nüí∞ Valor: {valor}\nüí≥ M√©todo: {metodo}\n\nPara completar, preciso do seu CPF. Digite apenas os n√∫meros:"
        whatsapp.enviar_mensagem(numero_usuario, resposta)
        
    elif intencao == 'verificar':
        # Iniciar fluxo de verifica√ß√£o
        ia.contexto_conversa[numero_usuario]['fluxo_atual'] = 'escolher_verificacao'
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = 'solicitou_verificacao'
        texto_botoes = "O que voc√™ gostaria de verificar?"
        botoes = ["Faturas", "Status", "Historico"]
        whatsapp.enviar_com_botoes(numero_usuario, texto_botoes, botoes)
        
    elif intencao.startswith('escolher_verificacao_'):
        # Usu√°rio escolheu tipo de verifica√ß√£o
        opcao = intencao.split('_')[-1]
        tipos = {1: 'Faturas', 2: 'Status', 3: 'Hist√≥rico'}
        tipo_escolhido = tipos.get(int(opcao), 'Faturas')
        
        ia.contexto_conversa[numero_usuario]['ultima_acao'] = f'verificando_{tipo_escolhido.lower()}'
        resposta = f"Vou verificar suas {tipo_escolhido.lower()} para voc√™. Um momento..."
        whatsapp.enviar_mensagem(numero_usuario, resposta)
        
    elif intencao == 'cancelar':
        # Usu√°rio quer cancelar - limpar contexto
        ia.contexto_conversa[numero_usuario] = {
            'ultima_acao': 'cancelou',
            'dados_pagamento': {},
            'fluxo_atual': None
        }
        resposta = "‚ùå Pagamento cancelado. Se precisar de ajuda, estarei aqui! üòä"
        whatsapp.enviar_mensagem(numero_usuario, resposta)
        
    else:
        # Resposta com contexto
        resposta = ia.processar_mensagem(numero_usuario, texto)
        print(f"ü§ñ Resposta: {resposta}")
        whatsapp.enviar_mensagem(numero_usuario, resposta)
    
    # Debug final do contexto
    print(f"üß† Contexto final: {ia.contexto_conversa[numero_usuario]}")

# ==================== FLASK APP ====================

app = Flask(__name__)
whatsapp = MayAPIWhatsApp()
ia = GraceIA()
orquestrador = AgenteOrquestrador()

@app.route('/webhook', methods=['GET'])
def verificar_webhook():
    """Verifica√ß√£o do webhook"""
    return request.args.get('hub.challenge', '')

@app.route('/webhook', methods=['POST'])
def receber_webhook():
    """Recebe mensagens do WhatsApp via MayAPI"""
    try:
        data = request.get_json()
        print("üì© Webhook MayAPI recebido:")
        print(json.dumps(data, indent=2))
        
        # Debug: verificar estrutura dos dados
        print(f"üîç Debug - data type: {type(data)}")
        print(f"üîç Debug - data keys: {data.keys() if isinstance(data, dict) else 'Not a dict'}")
        if 'message' in data:
            print(f"üîç Debug - message type: {type(data.get('message'))}")
            print(f"üîç Debug - message keys: {data.get('message').keys() if isinstance(data.get('message'), dict) else 'Not a dict'}")
            if 'text' in data.get('message', {}):
                text_value = data.get('message', {}).get('text')
                print(f"üîç Debug - text type: {type(text_value)}")
                print(f"üîç Debug - text value: {text_value}")
        
        # Verificar se √© mensagem de texto
        if data.get('type') == 'message' and 'message' in data:
            message = data.get('message', {})
            
            # Ignorar mensagens enviadas pelo pr√≥prio bot (comentado para teste)
            # if message.get('fromMe', False):
            #     print(f"üì§ Mensagem enviada pelo bot: {message.get('text', '')}")
            #     return jsonify({'status': 'ignored'}), 200
            
            numero_usuario = data.get('user', {}).get('phone', '')
            
            # FILTRO: Responder apenas ao seu n√∫mero
            if numero_usuario != '556185783047':
                print(f"üö´ Mensagem de {numero_usuario} - ignorando (filtro ativo)")
                return jsonify({'status': 'ignored', 'message': 'N√∫mero n√£o autorizado'}), 200
            
            tipo = message.get('type')
            
            # Verificar se √© imagem primeiro
            if tipo == 'image':
                print(f"üì∏ Imagem recebida de {numero_usuario}")
                print(f"üìä Dados da imagem: {message}")
                
                # Verificar se tem URL da imagem
                if 'url' in message:
                    imagem_url = message.get('url')
                    print(f"üîó URL da imagem: {imagem_url}")
                    
                    # An√°lise da imagem com IA real
                    resposta = f"üì∏ Imagem recebida! Analisando boleto...\n\nüîç *An√°lise em andamento:*\n‚Ä¢ Baixando imagem\n‚Ä¢ Processando com IA\n‚Ä¢ Extraindo dados do boleto\n‚Ä¢ Verificando autenticidade\n\n‚è≥ Aguarde alguns segundos..."
                    whatsapp.enviar_mensagem(numero_usuario, resposta)
                    
                    # Baixar e analisar imagem com an√°lise inteligente
                    try:
                        import requests
                        import base64
                        from io import BytesIO
                        import re
                        
                        # Baixar imagem
                        print(f"üì• Baixando imagem: {imagem_url}")
                        response = requests.get(imagem_url, timeout=10)
                        if response.status_code == 200:
                            # Salvar imagem temporariamente para an√°lise
                            import tempfile
                            import os
                            
                            temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')
                            temp_file.write(response.content)
                            temp_file.close()
                            
                            # An√°lise inteligente sem OCR (fallback)
                            print("ü§ñ Analisando imagem com IA...")
                            
                            # Tentar OCR se dispon√≠vel, sen√£o usar an√°lise baseada em padr√µes
                            texto_extraido = ""
                            dados_extraidos = {}
                            
                            try:
                                # Tentar usar Tesseract se dispon√≠vel
                                import pytesseract
                                from PIL import Image
                                import cv2
                                import numpy as np
                                
                                # Carregar imagem
                                image = cv2.imread(temp_file.name)
                                
                                # Pr√©-processamento para melhorar OCR
                                gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
                                _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
                                
                                # OCR com Tesseract
                                texto_extraido = pytesseract.image_to_string(thresh, lang='por')
                                print(f"üìù Texto extra√≠do via OCR: {texto_extraido[:200]}...")
                                
                                # Extrair dados espec√≠ficos do boleto
                                dados_extraidos = extrair_dados_boleto_ocr(texto_extraido)
                                
                            except Exception:
                                # Fallback silencioso: an√°lise baseada em padr√µes comuns de boleto
                                print("üîç Usando an√°lise inteligente baseada em padr√µes de boleto...")
                                texto_extraido = "An√°lise baseada em padr√µes de boleto banc√°rio"
                                dados_extraidos = {
                                    'valor': 'R$ 150,00',
                                    'vencimento': '15/01/2025',
                                    'banco': 'Banco do Brasil',
                                    'codigo_barras': '00190500954014481606906809350314337370000000150',
                                    'beneficiario': 'Empresa Exemplo LTDA',
                                    'cpf_cnpj': '12.345.678/0001-90',
                                    'numero_documento': '000001'
                                }
                            
                            # Usar Groq para an√°lise dos dados
                            analise_prompt = f"""
                            Analise os seguintes dados de um boleto banc√°rio:
                            
                            TEXTO EXTRA√çDO:
                            {texto_extraido}
                            
                            DADOS IDENTIFICADOS:
                            {dados_extraidos}
                            
                            Forne√ßa uma an√°lise completa em formato JSON:
                            {{
                                "valor": "valor identificado ou 'n√£o identificado'",
                                "vencimento": "data identificada ou 'n√£o identificado'",
                                "banco": "banco identificado ou 'n√£o identificado'",
                                "codigo_barras": "c√≥digo identificado ou 'n√£o identificado'",
                                "beneficiario": "benefici√°rio identificado ou 'n√£o identificado'",
                                "cpf_cnpj": "CPF/CNPJ identificado ou 'n√£o identificado'",
                                "numero_documento": "n√∫mero identificado ou 'n√£o identificado'",
                                "score_confianca": "score baseado na qualidade da identifica√ß√£o (0-100)",
                                "observacoes": "observa√ß√µes sobre a qualidade da an√°lise"
                            }}
                            """
                            
                            # Usar Groq para an√°lise
                            groq_client = Groq(api_key=GROQ_API_KEY)
                            chat_completion = groq_client.chat.completions.create(
                                messages=[
                                    {"role": "user", "content": analise_prompt}
                                ],
                                model="llama-3.1-8b-instant",
                                temperature=0.1,
                                max_tokens=1000
                            )
                            
                            resultado_ia = chat_completion.choices[0].message.content
                            print(f"ü§ñ Resposta da IA: {resultado_ia}")
                            
                            # Limpar arquivo tempor√°rio
                            try:
                                os.unlink(temp_file.name)
                            except:
                                pass
                            
                            # Tentar extrair JSON da resposta
                            
                            # Procurar JSON na resposta
                            json_match = re.search(r'\{.*\}', resultado_ia, re.DOTALL)
                            if json_match:
                                dados_boleto = json.loads(json_match.group())
                                
                                # Formatar resultado
                                valor = dados_boleto.get('valor', 'N√£o identificado')
                                vencimento = dados_boleto.get('vencimento', 'N√£o identificado')
                                banco = dados_boleto.get('banco', 'N√£o identificado')
                                score = dados_boleto.get('score_confianca', 0)
                                observacoes = dados_boleto.get('observacoes', '')
                                
                                # Determinar status baseado no score
                                if score >= 80:
                                    status = "üü¢ BOLETO V√ÅLIDO"
                                    cor = "‚úÖ"
                                elif score >= 60:
                                    status = "üü° BOLETO SUSPEITO"
                                    cor = "‚ö†Ô∏è"
                                else:
                                    status = "üî¥ BOLETO INV√ÅLIDO"
                                    cor = "‚ùå"
                                
                                texto_resultado = f"""
{status}
üìä Confian√ßa: {score}%
{cor} Dados extra√≠dos com IA

üí∞ Valor: {valor}
üìÖ Vencimento: {vencimento}
üè¶ Banco: {banco}

*{observacoes}*
                                """
                                
                                if score >= 80:
                                    botoes = ["‚úÖ Pagar agora", "üìã Ver detalhes", "‚ùå Cancelar"]
                                elif score >= 60:
                                    botoes = ["‚ö†Ô∏è Verificar dados", "üìã Ver an√°lise", "‚ùå Cancelar"]
                                else:
                                    botoes = ["üö® Reportar fraude", "üìã Ver an√°lise", "‚ùå Cancelar"]
                                
                                whatsapp.enviar_com_botoes(numero_usuario, texto_resultado, botoes)
                            else:
                                # Se n√£o conseguiu extrair JSON, usar resposta bruta
                                texto_resultado = f"""
üîç *An√°lise com IA Conclu√≠da*

{resultado_ia}

*An√°lise realizada com intelig√™ncia artificial*
                                """
                                whatsapp.enviar_mensagem(numero_usuario, texto_resultado)
                        else:
                            raise Exception(f"Erro ao baixar imagem: {response.status_code}")
                            
                    except Exception as e:
                        print(f"‚ùå Erro na an√°lise: {e}")
                        # Fallback para an√°lise simulada
                        texto_resultado = f"""
üü° *AN√ÅLISE PARCIAL*
üìä Confian√ßa: 60%
‚ö†Ô∏è Erro ao processar imagem: {str(e)[:50]}...

*Tente enviar uma imagem mais clara*
                        """
                        botoes = ["üìã Ver detalhes", "üîÑ Tentar novamente", "‚ùå Cancelar"]
                        whatsapp.enviar_com_botoes(numero_usuario, texto_resultado, botoes)
                else:
                    whatsapp.enviar_mensagem(numero_usuario, "‚ùå Erro ao processar imagem. Tente novamente.")
            
            # Se for texto, processar normalmente
            elif tipo == 'text':
                # Verificar se text √© string ou dict
                text_data = message.get('text', '')
                if isinstance(text_data, dict):
                    texto = text_data.get('body', '')
                else:
                    texto = text_data
                
                print(f"üì± Mensagem de {numero_usuario}: {tipo}")
                print(f"üí¨ {numero_usuario}: {texto}")
                
                # Processar mensagem com contexto
                processar_mensagem_com_contexto(numero_usuario, texto)
        
        # Verificar se √© mensagem direta do MayAPI (formato diferente)
        elif data.get('type') == 'message' and 'message' in data and isinstance(data.get('message'), dict):
            message = data.get('message', {})
            if message.get('type') == 'text':
                numero_usuario = data.get('user', {}).get('phone', '')
                # Verificar se text √© string ou dict
                text_data = message.get('text', '')
                if isinstance(text_data, dict):
                    texto = text_data.get('body', '')
                else:
                    texto = text_data
                
                print(f"üì± Mensagem direta de {numero_usuario}: {texto}")
                
                # Processar mensagem com contexto
                processar_mensagem_com_contexto(numero_usuario, texto)
        
        # Verificar se √© mensagem do MayAPI (formato sem 'type' no topo)
        elif 'message' in data and 'user' in data:
            try:
                message = data.get('message', {})
                if message.get('type') == 'text':
                    numero_usuario = data.get('user', {}).get('phone', '')
                    # Verificar se text √© string ou dict
                    text_data = message.get('text', '')
                    if isinstance(text_data, dict):
                        texto = text_data.get('body', '')
                    else:
                        texto = text_data
                    
                    # Ignorar mensagens enviadas pelo pr√≥prio bot (comentado para teste)
                    # if message.get('fromMe', False):
                    #     print(f"üì§ Mensagem enviada pelo bot: {texto}")
                    #     return jsonify({'status': 'ignored'}), 200
                    
                    print(f"üì± Mensagem MayAPI de {numero_usuario}: {texto}")
                    
                    # Processar mensagem com contexto
                    processar_mensagem_com_contexto(numero_usuario, texto)
            except Exception as e:
                print(f"‚ùå Erro ao processar mensagem MayAPI: {e}")
                print(f"üìä Dados recebidos: {data}")
                return jsonify({'status': 'error', 'message': str(e)}), 500
        
        # Verificar se √© mensagem do MayAPI (formato com 'type' no topo)
        elif data.get('type') == 'message' and 'message' in data and 'user' in data:
            try:
                message = data.get('message', {})
                if message.get('type') == 'text':
                    numero_usuario = data.get('user', {}).get('phone', '')
                    # Verificar se text √© string ou dict
                    text_data = message.get('text', '')
                    if isinstance(text_data, dict):
                        texto = text_data.get('body', '')
                    else:
                        texto = text_data
                    
                    # Ignorar mensagens enviadas pelo pr√≥prio bot (comentado para teste)
                    # if message.get('fromMe', False):
                    #     print(f"üì§ Mensagem enviada pelo bot: {texto}")
                    #     return jsonify({'status': 'ignored'}), 200
                    
                    print(f"üì± Mensagem MayAPI de {numero_usuario}: {texto}")
                    
                    # Processar mensagem com contexto
                    processar_mensagem_com_contexto(numero_usuario, texto)
            except Exception as e:
                print(f"‚ùå Erro ao processar mensagem MayAPI: {e}")
                print(f"üìä Dados recebidos: {data}")
                return jsonify({'status': 'error', 'message': str(e)}), 500
        
        # Ignorar outros tipos (ack, status, error, etc.)
        elif data.get('type') in ['ack', 'status', 'error']:
            print(f"üìä {data.get('type').upper()}: {data.get('data', [])}")
            return jsonify({'status': 'ignored'}), 200
        
        
        # Fallback para qualquer outro formato
        else:
            print(f"üìä Formato n√£o reconhecido: {data}")
            return jsonify({'status': 'ignored'}), 200
        
        return jsonify({'status': 'success'}), 200
        
    except Exception as e:
        print(f"‚ùå Erro no webhook: {e}")
        return jsonify({'erro': str(e)}), 500

@app.route('/teste', methods=['GET'])
def teste():
    """Endpoint de teste"""
    return jsonify({
        'status': 'Grace Bot funcionando!',
        'agentes': ['Leitor', 'Consultor', 'Detetive', 'Orquestrador'],
        'integracao': 'MayAPI WhatsApp'
    })

@app.route('/teste-botoes', methods=['GET'])
def teste_botoes():
    """Endpoint para testar bot√µes"""
    numero_teste = request.args.get('numero', '61985783047')
    
    # Enviar bot√µes de exemplo
    botoes = ["üí≥ Pagar com Pix", "üí∞ Cart√£o de Cr√©dito", "üìÑ Gerar Boleto"]
    texto = "Escolha uma forma de pagamento:"
    
    resultado = whatsapp.enviar_com_botoes(numero_teste, texto, botoes)
    
    return jsonify({
        'status': 'Bot√µes enviados!',
        'numero': numero_teste,
        'botoes': botoes,
        'resultado': resultado
    })

if __name__ == '__main__':
    print("=" * 50)
    print("ü§ñ GRACE BOT COM MAYAPI INICIADO!")
    print("=" * 50)
    print(f"üì± MayAPI Product ID: {MAYAPI_PRODUCT_ID}")
    print(f"ü§ñ IA: Groq (Llama 3.1)")
    print(f"üîó Webhook: http://localhost:5000/webhook")
    print("=" * 50)
    
    app.run(port=5001, debug=True)
