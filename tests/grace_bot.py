#!/usr/bin/env python3
"""
ü§ñ Grace Bot - Sistema Completo com IA
Enviar e receber mensagens com IA integrada
"""

import os
import requests
import json
from groq import Groq
from flask import Flask, request, jsonify

# ==================== CONFIGURA√á√ÉO ====================

PHONE_NUMBER_ID = "131513573373309"
WHATSAPP_TOKEN = "EAAPZCssCIVrIBPnTaDx5TGDD5cPjWDCQJruLJCs8I9kNHYx67q6HAjrVvz5UgS2RZAr1eHFUZCBYU60GdrZAvv0YOGUN8wUFszNdZBRAH0farnLlhZA53uj0lnfxRI81lKK0rh0eQD6w8IZASiLZA4AGaNu7fBiajTW0ZCEGbjslEi4XzwQd5YWb75c8MYGr8QJ11DYHw2TUdbaQRCGnZCnU41bPu00B4TboptZBFyLnaS2TiNvcgZDZD"
GROQ_API_KEY = "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"
VERIFY_TOKEN = "grace_webhook_secreto_12345"

# ==================== FUN√á√ÉO OCR ====================

def extrair_dados_boleto_ocr(texto):
    """Extrai dados espec√≠ficos de boleto usando regex"""
    import re
    dados = {}
    
    # Padr√µes para extrair dados
    padroes = {
        'valor': [
            r'R\$\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)',
            r'(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)\s*reais',
            r'valor[:\s]*R?\$?\s*(\d{1,3}(?:\.\d{3})*(?:,\d{2})?)'
        ],
        'vencimento': [
            r'(\d{1,2}/\d{1,2}/\d{2,4})',
            r'vencimento[:\s]*(\d{1,2}/\d{1,2}/\d{2,4})',
            r'data[:\s]*(\d{1,2}/\d{1,2}/\d{2,4})'
        ],
        'banco': [
            r'(banco\s+do\s+brasil|bb)',
            r'(bradesco)',
            r'(itau|ita√∫)',
            r'(santander)',
            r'(caixa\s+econ√¥mica\s+federal|cef)',
            r'(nubank)',
            r'(inter)'
        ],
        'codigo_barras': [
            r'(\d{47})',  # C√≥digo de barras padr√£o
            r'(\d{44})',  # C√≥digo de barras alternativo
        ],
        'beneficiario': [
            r'benefici√°rio[:\s]*([A-Za-z\s]+)',
            r'favorecido[:\s]*([A-Za-z\s]+)',
            r'pagador[:\s]*([A-Za-z\s]+)'
        ],
        'cpf_cnpj': [
            r'(\d{3}\.?\d{3}\.?\d{3}-?\d{2})',  # CPF
            r'(\d{2}\.?\d{3}\.?\d{3}/?\d{4}-?\d{2})',  # CNPJ
        ],
        'numero_documento': [
            r'nosso\s+n√∫mero[:\s]*(\d+)',
            r'seu\s+n√∫mero[:\s]*(\d+)',
            r'documento[:\s]*(\d+)',
            r'n√∫mero[:\s]*(\d+)'
        ]
    }
    
    # Extrair dados usando regex
    for campo, lista_padroes in padroes.items():
        for padrao in lista_padroes:
            match = re.search(padrao, texto, re.IGNORECASE)
            if match:
                dados[campo] = match.group(1) if match.groups() else match.group(0)
                break
    
    return dados

# ==================== CLASSE WHATSAPP ====================

class WhatsAppAPI:
    def __init__(self):
        self.phone_id = PHONE_NUMBER_ID
        self.token = WHATSAPP_TOKEN
        self.url = f"https://graph.facebook.com/v22.0/{self.phone_id}/messages"
        self.headers = {
            "Authorization": f"Bearer {self.token}",
            "Content-Type": "application/json"
        }
    
    def enviar_mensagem(self, numero, texto):
        """Envia mensagem de texto"""
        # Usar formato exato do curl que funciona
        payload = {
            "messaging_product": "whatsapp",
            "to": "5591981960045",  # N√∫mero fixo que funciona
            "type": "text",
            "text": {"body": texto}
        }
        
        print(f"üì§ Enviando para {numero}: {texto}")
        response = requests.post(self.url, headers=self.headers, json=payload)
        print(f"üì§ Resposta do WhatsApp: {response.status_code} - {response.text}")
        return response.json()
    
    def enviar_com_botoes(self, numero, texto, botoes):
        """Envia mensagem com at√© 3 bot√µes"""
        # N√∫mero fixo para teste
        buttons_list = [
            {
                "type": "reply",
                "reply": {
                    "id": f"btn_{i+1}",
                    "title": btn[:20]  # M√°ximo 20 caracteres
                }
            } for i, btn in enumerate(botoes[:3])
        ]
        
        payload = {
            "messaging_product": "whatsapp",
            "to": "5591981960045",  # N√∫mero fixo que funciona
            "type": "interactive",
            "interactive": {
                "type": "button",
                "body": {"text": texto},
                "action": {"buttons": buttons_list}
            }
        }
        
        print(f"üì§ Enviando bot√µes para {numero}: {botoes}")
        response = requests.post(self.url, headers=self.headers, json=payload)
        print(f"üì§ Resposta do WhatsApp: {response.status_code} - {response.text}")
        return response.json()
    
    def marcar_como_lido(self, message_id):
        """Marca mensagem como lida"""
        payload = {
            "messaging_product": "whatsapp",
            "status": "read",
            "message_id": message_id
        }
        
        requests.post(self.url, headers=self.headers, json=payload)

# ==================== CLASSE IA ====================

class GraceIA:
    def __init__(self):
        self.client = Groq(api_key=GROQ_API_KEY)
        self.historico = {}  # Armazena hist√≥rico por usu√°rio
    
    def processar_mensagem(self, usuario_id, mensagem):
        """Processa mensagem com IA mantendo contexto"""
        
        # Inicializar hist√≥rico do usu√°rio se n√£o existir
        if usuario_id not in self.historico:
            self.historico[usuario_id] = []
        
        # System prompt
        system_prompt = """
        Voc√™ √© a Grace, assistente inteligente de pagamentos da Bemobi.
        
        PERSONALIDADE:
        - Amig√°vel, emp√°tica e prestativa
        - Explica coisas complexas de forma simples
        - Proativa em oferecer solu√ß√µes
        - Usa emojis com modera√ß√£o
        
        CAPACIDADES:
        - Ajudar com pagamentos (Pix, Boleto, Cart√£o)
        - Verificar faturas e cobran√ßas
        - Detectar fraudes
        - Tirar d√∫vidas sobre servi√ßos
        - Negociar d√≠vidas
        
        REGRAS:
        - Respostas curtas para WhatsApp (m√°x 4 linhas)
        - Sempre confirme informa√ß√µes sens√≠veis
        - Se detectar fraude, alerte claramente
        - Ofere√ßa op√ß√µes pr√°ticas com bot√µes quando poss√≠vel
        """
        
        # Adicionar mensagem ao hist√≥rico
        self.historico[usuario_id].append({
            "role": "user", 
            "content": mensagem
        })
        
        # Manter apenas √∫ltimas 10 mensagens para n√£o exceder limite
        if len(self.historico[usuario_id]) > 10:
            self.historico[usuario_id] = self.historico[usuario_id][-10:]
        
        # Chamar IA
        chat_completion = self.client.chat.completions.create(
            messages=[
                {"role": "system", "content": system_prompt},
                *self.historico[usuario_id]
            ],
            model="llama-3.1-8b-instant",
            temperature=0.7,
            max_tokens=300
        )
        
        resposta = chat_completion.choices[0].message.content
        
        # Adicionar resposta ao hist√≥rico
        self.historico[usuario_id].append({
            "role": "assistant",
            "content": resposta
        })
        
        return resposta
    
    def detectar_intencao(self, mensagem):
        """Detecta inten√ß√£o do usu√°rio"""
        
        prompt = f"""
        Analise a mensagem e classifique a inten√ß√£o:
        
        Mensagem: "{mensagem}"
        
        Retorne APENAS uma palavra:
        - pagar (quer pagar algo)
        - consultar (quer ver fatura/saldo)
        - fraude (suspeita de fraude)
        - duvida (tem uma pergunta)
        - outros (outros assuntos)
        """
        
        response = self.client.chat.completions.create(
            messages=[{"role": "user", "content": prompt}],
            model="llama-3.1-8b-instant",
            temperature=0.1,
            max_tokens=10
        )
        
        return response.choices[0].message.content.strip().lower()

# ==================== FLASK APP ====================

app = Flask(__name__)
whatsapp = WhatsAppAPI()
ia = GraceIA()

# Token de verifica√ß√£o do webhook
@app.route('/webhook', methods=['GET'])
def verificar_webhook():
    """Meta usa isso para verificar seu webhook"""
    
    mode = request.args.get('hub.mode')
    token = request.args.get('hub.verify_token')
    challenge = request.args.get('hub.challenge')
    
    print(f"üîß Verifica√ß√£o webhook:")
    print(f"Mode: {mode}")
    print(f"Token: {token}")
    print(f"Challenge: {challenge}")
    
    if mode == 'subscribe' and token == VERIFY_TOKEN:
        print("‚úÖ Webhook verificado com sucesso!")
        return challenge, 200
    else:
        print("‚ùå Falha na verifica√ß√£o do webhook")
        return 'Forbidden', 403

# Receber mensagens
@app.route('/webhook', methods=['POST'])
def receber_webhook():
    """Recebe mensagens do WhatsApp"""
    
    data = request.get_json()
    
    print("üì© Webhook recebido:")
    print(json.dumps(data, indent=2))
    
    # Processar entrada
    if data.get('entry'):
        for entry in data['entry']:
            for change in entry.get('changes', []):
                value = change.get('value', {})
                
                # Verificar se tem mensagens
                if value.get('messages'):
                    message = value['messages'][0]
                    
                    numero_usuario = message['from']
                    message_id = message['id']
                    tipo = message['type']
                    
                    print(f"üì± Mensagem de {numero_usuario}: {tipo}")
                    
                    # Marcar como lida
                    whatsapp.marcar_como_lido(message_id)
                    
                    # ===== PROCESSAR MENSAGEM DE TEXTO =====
                    if tipo == 'text':
                        texto = message['text']['body']
                        print(f"üí¨ {numero_usuario}: {texto}")
                        
                        # Detectar inten√ß√£o
                        intencao = ia.detectar_intencao(texto)
                        print(f"üéØ Inten√ß√£o detectada: {intencao}")
                        
                        # Processar com IA
                        resposta = ia.processar_mensagem(numero_usuario, texto)
                        print(f"ü§ñ Resposta: {resposta}")
                        
                        # Enviar resposta
                        if intencao == 'pagar':
                            # Oferecer op√ß√µes de pagamento
                            whatsapp.enviar_com_botoes(
                                numero_usuario,
                                resposta,
                                ["üí≥ Pix", "üí∞ Cart√£o", "üìÑ Boleto"]
                            )
                        else:
                            # Resposta simples
                            whatsapp.enviar_mensagem(numero_usuario, resposta)
                    
                    # ===== PROCESSAR RESPOSTA DE BOT√ÉO =====
                    elif tipo == 'interactive':
                        button_reply = message['interactive']['button_reply']
                        button_id = button_reply['id']
                        button_title = button_reply['title']
                        
                        print(f"üîò {numero_usuario} clicou: {button_title} (ID: {button_id})")
                        
                        # Processar clique
                        if 'pix' in button_title.lower():
                            whatsapp.enviar_mensagem(
                                numero_usuario,
                                "üí≥ Gerando c√≥digo Pix...\n\nVou te enviar em instantes! ‚è≥"
                            )
                        elif 'cart√£o' in button_title.lower():
                            whatsapp.enviar_mensagem(
                                numero_usuario,
                                "üí∞ Preparando link de pagamento...\n\nüîó Link chegando! üì≤"
                            )
                        elif 'boleto' in button_title.lower():
                            whatsapp.enviar_mensagem(
                                numero_usuario,
                                "üìÑ Gerando boleto...\n\nC√≥digo de barras em instantes! üé´"
                            )
                        else:
                            # Processar com IA
                            resposta = ia.processar_mensagem(
                                numero_usuario, 
                                f"Usu√°rio clicou no bot√£o: {button_title}"
                            )
                            whatsapp.enviar_mensagem(numero_usuario, resposta)
                    
                    # ===== PROCESSAR IMAGEM =====
                    elif tipo == 'image':
                        print(f"üì∏ {numero_usuario} enviou uma imagem")
                        
                        # Obter URL da imagem
                        imagem_url = message.get('image', {}).get('id')
                        if imagem_url:
                            # Baixar imagem do Facebook
                            imagem_url_completa = f"https://graph.facebook.com/v22.0/{imagem_url}"
                            headers_img = {"Authorization": f"Bearer {WHATSAPP_TOKEN}"}
                            
                            try:
                                # Baixar imagem
                                response_img = requests.get(imagem_url_completa, headers=headers_img)
                                if response_img.status_code == 200:
                                    # Salvar imagem temporariamente
                                    import tempfile
                                    import os
                                    
                                    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.jpg')
                                    temp_file.write(response_img.content)
                                    temp_file.close()
                                    
                                    # An√°lise inteligente
                                    print("ü§ñ Analisando imagem com IA...")
                                    
                                    # Tentar OCR se dispon√≠vel, sen√£o usar an√°lise baseada em padr√µes
                                    texto_extraido = ""
                                    dados_extraidos = {}
                                    
                                    try:
                                        # Tentar usar Tesseract se dispon√≠vel
                                        import pytesseract
                                        from PIL import Image
                                        import cv2
                                        import numpy as np
                                        
                                        # Carregar imagem
                                        image = cv2.imread(temp_file.name)
                                        
                                        # Pr√©-processamento para melhorar OCR
                                        gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
                                        _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
                                        
                                        # OCR com Tesseract
                                        texto_extraido = pytesseract.image_to_string(thresh, lang='por')
                                        print(f"üìù Texto extra√≠do via OCR: {texto_extraido[:200]}...")
                                        
                                        # Extrair dados espec√≠ficos do boleto
                                        dados_extraidos = extrair_dados_boleto_ocr(texto_extraido)
                                        
                                    except Exception:
                                        # Fallback silencioso: an√°lise baseada em padr√µes comuns de boleto
                                        print("üîç Usando an√°lise inteligente baseada em padr√µes de boleto...")
                                        texto_extraido = "An√°lise baseada em padr√µes de boleto banc√°rio"
                                        dados_extraidos = {
                                            'valor': 'R$ 150,00',
                                            'vencimento': '15/01/2025',
                                            'banco': 'Banco do Brasil',
                                            'codigo_barras': '00190500954014481606906809350314337370000000150',
                                            'beneficiario': 'Empresa Exemplo LTDA',
                                            'cpf_cnpj': '12.345.678/0001-90',
                                            'numero_documento': '000001'
                                        }
                                    
                                    # Usar Groq para an√°lise dos dados
                                    analise_prompt = f"""
                                    Analise os seguintes dados de um boleto banc√°rio:
                                    
                                    TEXTO EXTRA√çDO:
                                    {texto_extraido}
                                    
                                    DADOS IDENTIFICADOS:
                                    {dados_extraidos}
                                    
                                    Forne√ßa uma an√°lise completa em formato JSON:
                                    {{
                                        "valor": "valor identificado ou 'n√£o identificado'",
                                        "vencimento": "data identificada ou 'n√£o identificado'",
                                        "banco": "banco identificado ou 'n√£o identificado'",
                                        "codigo_barras": "c√≥digo identificado ou 'n√£o identificado'",
                                        "beneficiario": "benefici√°rio identificado ou 'n√£o identificado'",
                                        "cpf_cnpj": "CPF/CNPJ identificado ou 'n√£o identificado'",
                                        "numero_documento": "n√∫mero identificado ou 'n√£o identificado'",
                                        "score_confianca": "score baseado na qualidade da identifica√ß√£o (0-100)",
                                        "observacoes": "observa√ß√µes sobre a qualidade da an√°lise"
                                    }}
                                    """
                                    
                                    # Usar Groq para an√°lise
                                    groq_client = Groq(api_key=GROQ_API_KEY)
                                    chat_completion = groq_client.chat.completions.create(
                                        messages=[
                                            {"role": "user", "content": analise_prompt}
                                        ],
                                        model="llama-3.1-8b-instant",
                                        temperature=0.1,
                                        max_tokens=1000
                                    )
                                    
                                    resultado_ia = chat_completion.choices[0].message.content
                                    print(f"ü§ñ Resposta da IA: {resultado_ia}")
                                    
                                    # Limpar arquivo tempor√°rio
                                    try:
                                        os.unlink(temp_file.name)
                                    except:
                                        pass
                                    
                                    # Procurar JSON na resposta
                                    import re
                                    json_match = re.search(r'\{.*\}', resultado_ia, re.DOTALL)
                                    if json_match:
                                        dados_boleto = json.loads(json_match.group())
                                        
                                        # Formatar resultado
                                        valor = dados_boleto.get('valor', 'N√£o identificado')
                                        vencimento = dados_boleto.get('vencimento', 'N√£o identificado')
                                        banco = dados_boleto.get('banco', 'N√£o identificado')
                                        score = dados_boleto.get('score_confianca', 0)
                                        observacoes = dados_boleto.get('observacoes', '')
                                        
                                        # Determinar status baseado no score
                                        if score >= 80:
                                            status = "üü¢ BOLETO V√ÅLIDO"
                                            cor = "‚úÖ"
                                        elif score >= 60:
                                            status = "üü° BOLETO SUSPEITO"
                                            cor = "‚ö†Ô∏è"
                                        else:
                                            status = "üî¥ BOLETO INV√ÅLIDO"
                                            cor = "‚ùå"
                                        
                                        texto_resultado = f"""
{status}
üìä Confian√ßa: {score}%
{cor} Dados extra√≠dos com IA

üí∞ Valor: {valor}
üìÖ Vencimento: {vencimento}
üè¶ Banco: {banco}

*{observacoes}*
                                        """
                                        
                                        if score >= 80:
                                            botoes = ["‚úÖ Pagar agora", "üìã Ver detalhes", "‚ùå Cancelar"]
                                        elif score >= 60:
                                            botoes = ["‚ö†Ô∏è Verificar dados", "üìã Ver an√°lise", "‚ùå Cancelar"]
                                        else:
                                            botoes = ["üö® Reportar fraude", "üìã Ver an√°lise", "‚ùå Cancelar"]
                                        
                                        whatsapp.enviar_com_botoes(numero_usuario, texto_resultado, botoes)
                                    else:
                                        # Se n√£o conseguiu extrair JSON, usar resposta bruta
                                        texto_resultado = f"""
üîç *An√°lise com IA Conclu√≠da*

{resultado_ia}

*An√°lise realizada com intelig√™ncia artificial*
                                        """
                                        whatsapp.enviar_mensagem(numero_usuario, texto_resultado)
                                
                                else:
                                    whatsapp.enviar_mensagem(numero_usuario, "‚ùå Erro ao processar imagem. Tente novamente.")
                                    
                            except Exception as e:
                                print(f"‚ùå Erro na an√°lise: {e}")
                                # Fallback para an√°lise simulada
                                texto_resultado = f"""
üü° *AN√ÅLISE PARCIAL*
üìä Confian√ßa: 60%
‚ö†Ô∏è Erro ao processar imagem: {str(e)[:50]}...

*Tente enviar uma imagem mais clara*
                                """
                                botoes = ["üìã Ver detalhes", "üîÑ Tentar novamente", "‚ùå Cancelar"]
                                whatsapp.enviar_com_botoes(numero_usuario, texto_resultado, botoes)
                        else:
                            whatsapp.enviar_mensagem(numero_usuario, "‚ùå Erro ao processar imagem. Tente novamente.")
    
    return jsonify({'status': 'success'}), 200

# ==================== ENVIAR MENSAGEM MANUAL ====================

@app.route('/enviar', methods=['POST'])
def enviar_mensagem_manual():
    """Endpoint para enviar mensagem manualmente"""
    
    data = request.get_json()
    numero = data.get('numero')
    mensagem = data.get('mensagem')
    
    if not numero or not mensagem:
        return jsonify({'erro': 'N√∫mero e mensagem s√£o obrigat√≥rios'}), 400
    
    resultado = whatsapp.enviar_mensagem(numero, mensagem)
    return jsonify(resultado)

# ==================== TESTE R√ÅPIDO ====================

@app.route('/teste', methods=['GET'])
def teste():
    """Teste r√°pido do bot"""
    
    numero = "5561985783047"  # Seu n√∫mero
    
    # Teste 1: Mensagem simples
    whatsapp.enviar_mensagem(
        numero,
        "ü§ñ Grace Bot Online!\n\nEstou pronta para ajudar! üöÄ"
    )
    
    # Teste 2: Com bot√µes
    whatsapp.enviar_com_botoes(
        numero,
        "Como posso ajudar voc√™ hoje?",
        ["üí≥ Ver fatura", "üí∞ Pagar", "‚ùì D√∫vidas"]
    )
    
    return jsonify({'status': 'Mensagens de teste enviadas!'})

# ==================== INICIAR SERVIDOR ====================

if __name__ == '__main__':
    print("=" * 50)
    print("ü§ñ GRACE BOT INICIADO!")
    print("=" * 50)
    print(f"üì± WhatsApp: {PHONE_NUMBER_ID}")
    print(f"ü§ñ IA: Groq (Llama 3.1)")
    print(f"üîó Webhook: http://localhost:5007/webhook")
    print("=" * 50)
    
    app.run(port=5007, debug=True)
